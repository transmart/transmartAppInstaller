import org.apache.tools.ant.taskdefs.Ant

import java.util.concurrent.TimeUnit

/*************************************************************************
 * transmartAppInstaller meant for  tranSMART - translational medicine data mart
 *
 *
 * Apache License, Version 2.0, January 2004
 *
 * Copyright 2012 The Hyve B.V.
 *
 * Author : pieter lukasse (pieter@thehyve.nl)
 *
 ******************************************************************/



/**
 * This script automates the steps needed to setup:
 *
 * the tranSMART DB
 * the i2b2 DB
 * demo data
 *
 * It does this in a Postgres DB. This setup is well suited for a development environment.
 *
 * Pre-requisites (available from command line - or configured in setupTranSMARTDevelopment.properties):
 *
 *  - git
 *  - psql (postgres sql )
 *  - a properly configured setupTranSMARTDevelopment.properties
 *  - (optional) pre-configured jboss (JBoss 4.2.2.GA see
 *    http://transmartproject.org/wiki/download/attachments/30441474/jboss-4.2.2.GA.tar.gz )
 *
 * @author : pieter lukasse (pieter@thehyve.nl)
 */

info = this.&echo.curry('info')
warn = this.&echo.curry('warning')

def properties = readProperties("setupTranSMARTDevelopment.properties")
properties.getAt = { delegate.getProperty(it) }

String.metaClass.or = { String s -> new File(delegate, s).path }
String.metaClass.compareVersion = { String s ->
    def arrs = [delegate, s].collect { it.split(/\./) as List }
    while (arrs.any()) {
        def cur = arrs*.getAt(0).collect { it ?: 0 } as int[]
        def r = cur[0] <=> cur[1]
        if (r) return r
        arrs = arrs*.drop(1)
    }
    return 0
}
File.metaClass.or = { String s -> new File(delegate, s).path }

tools_git_cmd                    = properties["tools.git.cmd"]
tools_psql_cmd                   = properties["tools.psql.cmd"]
tools_ant_cmd                    = properties["tools.ant.cmd"]

locations_jboss                  = properties["locations.jboss"] //leave empty in order not to setup i2b2 runtime
ports_jboss                      = properties["ports.jboss"] //TODO jboss port can be read from ${locations_jboss}/server/default/deploy/jboss-web.deployer/server.xml
ports_solr                       = properties["ports.solr"]

locations_tomcat                 = properties["locations.tomcat"]
locations_plink_exec             = properties["locations.plink.executables"]

build_dir                        = properties["locations.build.out"]
transmart_db_name                = "transmart"  //untested with other names
transmart_db_tablespace_location = properties["locations.db.tablespaces"]
transmartuser_home               = properties["locations.transmartuser.home"]

pg_user                          = properties['postgres.user'] // database user
pg_password                      = properties['postgres.password']
pg_database                      = properties['postgres.workingdb']
pg_host                          = properties['postgres.host']
pg_port                          = properties['postgres.port']

webapps_subdir                   = 'applications'
webapps_data                     = 'appdata'

//some handy derived globals:
ant_last_step_output             = new File(getTempDir(), "ant_last_step_out.txt")

/*  Set in validate: */
host_os_type = null
exec_postfix = null
git_has_single_version = null
psql_sudo_user = null
pg_effective_user = null
pg_process_user = null

validateEnvironment()

def validateEnvironment() {
    def result

    /* System idiosyncrasies */
    if (System.properties['os.name'].toLowerCase().contains('windows'))
        host_os_type = "windows"
    else
        host_os_type = "unix"

    exec_postfix = host_os_type == "windows" ? '.exe' : ''

    /* {{{ Git */
    tools_git_cmd = tools_git_cmd ?: which('git')
    if (!tools_git_cmd) {
        fail 'Git executable location not specified'
    }
    if (!new File(tools_git_cmd).canExecute()) {
        fail 'Git location "%s" is invalid', tools_git_cmd
    }

    try {
        result = ([tools_git_cmd, '--version'].execute().text =~ /(?:\d+\.)+\d+/)[0]
        git_has_single_branch = result.compareVersion('1.7.10') >= 0
        if (!git_has_single_branch) {
            warn 'Your version of git does not support --single-branch; ' +
                    'checkout times will be longer'
        }
    } catch (e) {
        fail 'Could not determine git version: %s', e.message
    }
    /* }}} */

    /* {{{ psql */
    tools_psql_cmd = tools_psql_cmd ?: which('psql')
    if (!tools_psql_cmd) {
        fail 'psql executable location not specified'
    }
    if (!new File(tools_psql_cmd).canExecute()) {
        fail 'psql location "%s" is invalid', tools_psql_cmd
    }

    if (!pg_database && !System.getenv('PGDATABASE')) {
        pg_database = pg_user ?: System.getProperty("user.name")
        warn 'postgres.workingdb was not specified, trying "%s"', pg_database
    }

    // Test whether we want to change user
    psql_sudo_user = null
    if (host_os_type == 'unix') {
        result = executePsql(['-t', '-c', 'select 1'], failOnError: false)

        if (!result) {
            if (!pg_user) {
                warn "Not trying sudo because no db user was specified"
                fail "Failed connecting to the database. Check your settings;" +
                        " see README for more information"
            }

            warn "Failed connecting to the database. Trying now with sudo"
            psql_sudo_user = pg_user
            result = executePsql(['-t', '-c', 'select 2'], failOnError: false)

            if (!result) {
                info "Could not connect to the database. Check your settings;" +
                        " see README for more information"
                fail "Abort"
            }
        }
    }
    result = executePsql(['-t', '-c', 'select rolsuper, current_user ' +
            'from pg_authid where rolname = current_user'], failOnError: false)
    if (!result) {
        fail "Could not execute postgresql superuser probe. Check your settings"
    }
    def output = ant_last_step_output.text.split(/\|/)*.trim() as List
    if (output[0] != "t") {
        fail "The user we're connecting as, '%s', is not a DB super user",
                output[1]
    }
    pg_effective_user = output[1]
    info "We are using the database role '%s'", output[1]

    if (host_os_type == 'unix') {
        def q = new java.util.concurrent.ArrayBlockingQueue(1)
        executePsql(['-t', '-q'],
                callback: { Map params, List command ->
                    Thread.start {
                        def pb = new ProcessBuilder(*command)
                        pb.environment().putAll(params.environment)
                        def p = pb.start()
                        p.out << 'select pg_backend_pid();\n'
                        def r = new BufferedReader(new InputStreamReader(p.in))
                        def pid = r.readLine()?.trim()
                        if (pid)
                            q.add("ps -ouser= -p $pid".execute().in.text.trim())
                        else
                            q.add(false)
                        p.in.close()
                    }
                });

        pg_process_user = q.poll(3, TimeUnit.SECONDS)
        if (!pg_process_user) {
            warn "Could not determine the user PostgreSQL runs as"
        } else {
            info "PostgreSQL user detected: '%s'", pg_process_user
        }
    }
    /* }}} */

    /* {{{ Ant */
    if (!tools_ant_cmd) {
        if (host_os_type == 'unix') {
            def thisFile = binding.'gant.file'.substring('file:'.length())
            tools_ant_cmd = new File(thisFile).parent | 'ant'
        } else {
            fail 'Ant location not specified. Check tools.ant.cmd'
        }
    }
    if (!new File(tools_ant_cmd).canExecute()) {
        fail 'Ant location "%s" is invalid', tools_ant_cmd
    }
    result = commandStepN([tools_ant_cmd, "-version"], failOnError: false)
    if (!result) {
        fail "Failed on invocation of ant -version"
    }
    /* }}} */

    /* {{{ Validation of directories */
    def dirValidation = { settingName, directory ->
        info "Checking directory %s...", directory
        if (!directory) {
            fail "%s is not set", settingName
        }
        if (!new File(directory).exists()) {
            warn "Directory %s does not exist; trying to create...", directory
            ant.mkdir(dir: directory)
        }
        if (!new File(directory).canWrite()) {
            fail "No write permissions in %s, check %s", directory, settingName
        }
    }
    dirValidation "locations.build.out",          build_dir
    dirValidation "locations.db.tablespace",      transmart_db_tablespace_location
    dirValidation "locations.transmartuser.home", transmartuser_home
    /* }}} */

    info "Everything validated, let's start"
}

target('default': "cleanup and setup") {
    clean()
    newInstall()
}

target(cleanBuildDir: 'delete build dir contents')
{
    /* This target must be invoked explicitly */
    delete(verbose: true, includeemptydirs: true) {
        fileset dir: build_dir, includes: '**/*', defaultexcludes: false
    }
}

target(clean: "clean-up to run again...")
{
	clean_db()
	clean_config_files()
}

target(clean_db: "clean out the database...")
{
    //drop postgres "transmart" db:
    echo ("If Drop database fails, check for existing connections to the database")
    def command =  "drop database if exists $transmart_db_name"
    dbCommand(command, failOnError: true)

    //drop roles
    roles = ['biomart', 'biomart_user', 'deapp', 'i2b2demodata', 'i2b2hive',
            'i2b2metadata', 'i2b2pm', 'i2b2workdata', 'searchapp', 'tm_cz',
            'tm_lz', 'tm_wz'];
    command = "reassign owned by ${roles.join(', ')} to $pg_effective_user;"
    dbCommand(command, failOnError: false)
    roles.each {
        dbCommand("drop role $it", failOnError: false, quiet: true)
    }
}

target(clean_config_files: "clean out the config files...")
{
    //remove <user_home>/.grails/transmartConfig files:
    delete(dir: transmartuser_home | ".grails/transmartConfig")
}

target(newInstall: "Install only the GEO studies, GSE9150, GSE4382, GSE14860") {
    
    def scriptDir = build_dir | "transmartApp-DB/postgresql_version"
    
    ensureTablespaces() /* do this first due to high probability of failure */

    createTransmartDB()
   
    fetchDBScripts()    

    addRoles()    

    createTablespaces()

    installGEOStudies()    
        
    configSteps()
    
}

target(fetchDBScripts: "fetch the postgresMigrate branch of transmartApp-DB")
{
    gitStep("https://github.com/transmart/transmartApp-DB.git",
            build_dir | "transmartApp-DB", "postgresMigrate", true)
}

target(createTablespaces: "Create the tablespace entries for the GEO studies")
{
    def scriptDir = build_dir | "transmartApp-DB/postgresql_version"
    scriptFileName = "tablespaces.sql"
    updateStudyInstallTablespaceLocations(scriptDir | scriptFileName, "/opt/transmart/db")
    dbScriptStep(scriptFileName, transmart_db_name, true, true, scriptDir);
}

target(addRoles: "Add the database roles for GEO studies")
{
    def scriptDir = build_dir | "transmartApp-DB/postgresql_version"
    def scriptFileName = "roles.sql"
    dbScriptStep(scriptFileName, transmart_db_name, true, true, scriptDir);
}

target(installGEOStudies: "install the three GEO studies that were pulled from the GA1.0 release")
{
	echo ("loading dump files - takes a while - up to 10 min")
	
    def scriptDir = build_dir | "transmartApp-DB/postgresql_version"
    def file = new File(scriptDir, "all_but_tm.dump")
    executePsql(
       dir: build_dir,
       database: transmart_db_name,
       [file.getPath()],
       new File(tools_psql_cmd).parent.toString() | 'pg_restore' + exec_postfix
    )

    file = new File(scriptDir, "tm_schema_only.dump")
    executePsql(
        dir: build_dir,
        database: transmart_db_name,
        [file.getPath()],
        new File(tools_psql_cmd).parent.toString() | 'pg_restore' + exec_postfix
	)
}

def updateStudyInstallTablespaceLocations(String scriptFileLocation, String targetString)
{
    //read script file and replace targetString with transmart_db_tablespace_location
    def scriptTemp = file2String(scriptFileLocation)
    scriptTemp = scriptTemp.replaceAll(targetString, transmart_db_tablespace_location)
    string2File(scriptTemp, scriptFileLocation)
    return scriptFileLocation;
}

target(install: "The installation script") {

    ensureTablespaces() /* first due to high prob of failure */

//    Build tranSMART demo-data Tables
//
//    github - clone script repository
//    create/find and cd to your github directory
//    git clone https://github.com/transmart/transmartApp-DB
//    change to branch: create a “tracking branch” for postgresMigrate
//    cd transmartApp-DB
//    git checkout -b postgresMigrate origin/postgresMigrate
//    Build initiial PostgreSQL databases (for both transMart and i2b2)
//    cd postgresql , then instructions in readme
    gitStep("https://github.com/transmart/transmartApp-DB.git",
            build_dir | "transmartApp-DB", "postgresMigrate", true)

//    There are 3 main steps to creating the transmart database:
//    1.  Create the transmart schemas (and all objects not part of i2b2 or ETL)
//    2.  Execute the i2b2 postgresql database import scripts to
//    create the transmart-specific i2b2 objects, linkages, and data
//    3.  Create the ETL schema objects

    createTransmartDB()

//   Step 1:
//    The create-main.sql script will drop and then create schemas, objects,
//    and seed data in the transmart database. Takes quite some time
    populateTransmartDB()

    verifyTransmartDB()

//    Step 2: Execute the i2b2 postgresql import scripts
	if (locations_jboss) {
		downloadI2B2()
	}
    
    executeI2b2ImportScripts()

//    Step 3: Post-i2b2 scripts (substitute for localhost, if appropriate)
    executePostI2b2Scripts()

    configSteps()
}

target(configSteps: "final configuration steps")
{
    configTransmartApp()
}

target(populateTransmartDB: "populateTransmartDB - filling the database. Please wait, this can take some minutes... ")
{
    fixTablespaceLocation(build_dir | "transmartApp-DB/postgresql/tablespaces.sql")

    /* create dump: stop after verifyTransmartDB and run:
     * pg_dump -c -F c gustavo -f \
     *  dump_`git ls-remote https://github.com/transmart/transmartApp-DB.git -b postgresMigrate | head -c 7`_db
     */
    /* See if we have a dump for this version of transmartApp-DB */
    def dir = build_dir | "transmartApp-DB" | '.git'
    //content: 'ref: refs/heads/postgresql-branch'
    def head = new File(dir, 'HEAD').text.trim().split(/ /)[1]
    def rev = new File(dir, head).text[0..6]

    def filename = "dump_${rev}_db"
    def file = new File(build_dir, filename)
    def url = new URL("http://files.thehyve.net/$filename")
    def out = new BufferedOutputStream(new FileOutputStream(file))

    try {
        out << url.openStream()
        out.close()

        /* the dump does not include tablespace definitions or roles,
         * so we have to use the scripts here */
        [
                'tablespaces.sql',
                'biomart_user.sql',
                'searchapp/prerequisites.sql',
                'biomart/prerequisites.sql',
                'deapp/prerequisites.sql',
                'i2b2_prerequisites.sql',
                'bmuser_search_path.sql',
        ].each {
            dbScriptStep(build_dir | "transmartApp-DB/postgresql" | it,
                    transmart_db_name, true, true,
                    build_dir | "transmartApp-DB/postgresql", false)
        }

        /* alas, the scripts above also create schemas,
          * which have to be dropped at this point */
        def drops = "drop schema if exists biomart, deapp, searchapp, i2b2demodata, " +
                "i2b2hive, i2b2metadata, i2b2pm, i2b2workdata cascade;"
        dbCommand(drops, database: transmart_db_name)

        executePsql(
                dir: build_dir,
                database: transmart_db_name,
                [file.getPath()],
                new File(tools_psql_cmd).parent.toString() | 'pg_restore' + exec_postfix
        )
    } catch (e) {
        warn "Could not download or import dump file; reverting to SQL " +
                "scripts (${e.message})"
        dbScriptStep(build_dir |
                "transmartApp-DB/postgresql/create-main.sql",
                transmart_db_name, true, true,
                build_dir | "transmartApp-DB/postgresql", false)
    }
}

target(verifyTransmartDB: "verify transmartDB data is OK")
{
//  Verify SEARCHAPP table row counts using searchapp/data/check_counts.sql.
    verifySEARCHAPPdata()
//  Verify DEAPP table row counts using deapp/data/check_counts.sql.
    verifyDEAPPdata()
//  Verify BIOMART table row counts using biomart/data/check_counts.sql.
    verifyBIOMARTdata()
}

target(downloadI2B2: "Downloading and installing i2b2 version of tranSMART 1.0 GA")
{
    def archive_file = build_dir | "jboss.tar.gz"

    //Download i2b2 archive
    ant.get(
        src: "http://transmartproject.org/wiki/download/attachments/30441474/jboss-4.2.2.GA.tar.gz?version=1&modificationDate=1335242608000",
        dest: archive_file
    )

    //extract archive and move into the target JBoss location
    ant.untar(src: archive_file, dest: build_dir, compression: "gzip")
    ant.move(file: build_dir | "jboss-4.2.2.GA", tofile: locations_jboss)

    //Download PostgreSQL driver
    ant.get(
        src: "http://jdbc.postgresql.org/download/postgresql-9.2-1002.jdbc4.jar",
        dest: locations_jboss | "server" | "default" | "lib"
    )
}


target(configTransmartApp: "setting up the configuration files in <user home>/.grails/transmartConfig/")
{
    //git clone https://github.com/transmart/transmartApp-Config.git  branch   postgresMigrate
    def transmartConfigDir = build_dir | "transmartApp-Config"
    gitStep("https://github.com/transmart/transmartApp-Config.git", transmartConfigDir, "postgresMigrate")

//    Checkout contains:
//    External configuration files for transmart application
//    Config.groovy - transmart application configuration file
//    DataSource.groovy - jdbc and connection pool configuration
//    RmodulesConfig.groovy - configuration file for the R plugin module
//
//    these files should be put under this folder:
//        ${transmartUser HOME Dir}/.grails/transmartConfig

//    TODO NOTE: the name of the configuration directory is determined by the name
//    of the application, and the name of the application is set in the file
//    application.properties in the top level directory of transmartApp. For now, this script is assuming the name "transmart" is set.

    def transmartConfigAtUserHome = transmartuser_home | ".grails/transmartConfig"
    mkdir(dir: transmartConfigAtUserHome)

    //Copy all .groovy files to this folder:
    copy(todir: transmartConfigAtUserHome) {
        fileset (dir: transmartConfigDir) {
            include(name: "*.groovy")
        }
    }
    //nb: the ant as in "ant.copy" above is not needed. Calling Ant tasks in a Gant closure is so common that Gant automatically
    //tries the ant object during function lookup. Hence the ant. prefix is not needed

    //adjust Config.groovy:
    def configGroovy = transmartConfigAtUserHome | "Config.groovy"

    replacePropertyInFile(configGroovy,
            "com.recomdata.searchengine.index",
            locations_tomcat | webapps_data | "transmart/index", true)

    // i2b2 project management cell url
    replacePropertyInFile(configGroovy,
            "com.recomdata.datasetExplorer.pmServiceURL", "http://localhost:${ports_jboss}/i2b2/rest/PMService/", true)

    //TODO  genePattern (tool from BroadInstitute) settings?

    //PLINK config: Whole genome association analysis toolset from http://pngu.mgh.harvard.edu/~purcell/plink/
    replacePropertyInFile(configGroovy,
            "com.recomdata.datasetExplorer.plinkExcutable", locations_plink_exec, true)

    //SOLR ("Lucene-based search server" from Apache) config:
    replacePropertyInFile(configGroovy,
            "com.recomdata.solr.baseURL", "http://localhost:${ports_solr}", true)


    //This is the directory to the R plugins.
    replacePropertyInFile(configGroovy,
            "com.recomdata.plugins.pluginScriptDirectory",
            locations_tomcat | webapps_subdir | "transmart/plugins/", true)

    //This is the main temporary directory, under this should be the folders that get created per job.
    replacePropertyInFile(configGroovy,
            "com.recomdata.plugins.tempFolderDirectory",
            getTempDir() | "jobs", true)

    //Use this to do local development.  It causes the analysis controllers to move the image file before rendering it.
    replacePropertyInFile(configGroovy,
            "com.recomdata.plugins.transferImageFile", "true", false)

    //This is the system path where we move the image file to so we can serve it.
    replacePropertyInFile(configGroovy,
            "com.recomdata.plugins.temporaryImageFolder",
            locations_tomcat | webapps_subdir | "transmart/images/tempImages", true)

    //some dir related to R ?
    replacePropertyInFile(configGroovy,
            "com.recomdata.transmart.data.export.rScriptDirectory",
            locations_tomcat | webapps_subdir | "transmart/dataExportRScripts", true)


    //TODO : do something with com.recomdata.plugins.analysisImageURL?


    //TODO - edit DataSource.config to reflect your postgreSQL (you might have to change host, port, username, password)    - this is left with DEFAULT values for now



    //Edit RModulesConfig.groovy, look at these values
    //
    //    pluginScriptDirectory
    //    tempFolderDirectory
    //    temporaryImageFolder (writable)
    //    imageURL (corresponds to temporaryImageFolder) - TODO - check how this can be used...?
    def rmodulesGroovy = transmartConfigAtUserHome | "RModulesConfig.groovy"
    //pluginScriptDirectory, temporaryImageFolder
    replaceInFile(rmodulesGroovy, "/your/tomcat", locations_tomcat)
     //tempFolderDirectory
    replaceInFile(rmodulesGroovy,
            "tempFolderDirectory = \"/var/tmp/jobs/\"",
            "tempFolderDirectory = \"" + getTempDir() +"jobs/\"" )

}


target(executePostI2b2Scripts: "the POST I2b2 Import Scripts")
 {
//     This includes the ETL schema objects (first, because of dependencies)
//
//     a. psql -h localhost -U postgres -d transmart -f i2b2-grants.sql --quiet
//     b  psql -h localhost -U postgres -d transmart -f etl/start.sql --quiet
//     c. psql -h localhost -U postgres -d transmart -f post-i2b2.sql --quiet

     dbScriptStep(build_dir | "transmartApp-DB/postgresql/i2b2-grants.sql",
             transmart_db_name, true, true,
             build_dir | "transmartApp-DB/postgresql")

     dbScriptStep(build_dir | "transmartApp-DB/postgresql/etl/start.sql",
             transmart_db_name, true, true,
             build_dir | "transmartApp-DB/postgresql")

     dbScriptStep(build_dir | "transmartApp-DB/postgresql/post-i2b2.sql",
             transmart_db_name, true, true,
             build_dir | "transmartApp-DB/postgresql")
 }

target(executeI2b2ImportScripts: "execute I2b2 Import Scripts")
{
    //    a. Execute the i2b2_prerequisites.sql script
    dbScriptStep(build_dir | "transmartApp-DB/postgresql/i2b2_prerequisites.sql",
            transmart_db_name, true, true)

//    Download i2b2 upgrades and data loading for PostgreSQL upgrade - github/transmart/i2b2_1.6_postgres
//    Use master branch
    def i2b2Dir = build_dir | "i2b2_1.6_postgres"
    gitStep("https://github.com/transmart/i2b2_1.6_Postgres.git", i2b2Dir)

//    a2.  Execute the i2b2 postgresql import scripts
//    From i2b2Dir/readme :
//    see demodata/src/src/edu.harvard.i2b2.data/Release_1-6/NewInstall/Data load instructions.docx
//    and coreserver/src/README.txt

//    demodata - scrips for building the postgres version of the demo data
    i2b2Demodata()

//    coreserver - source files for building the core i2b2 modules used by tranSMART
	if (locations_jboss) {
		i2b2Coreserver()
	}
}

target(i2b2Demodata: "loading i2b2 demo data")
{
    def i2b2Dir = build_dir | "i2b2_1.6_postgres"  //TODO remove this
    // redundant line of code...
    def demodataDir = i2b2Dir | "demodata/src/src/edu.harvard.i2b2.data/Release_1-6/NewInstall/"
    //    1. Set appropriate values for properties mentioned in db.properties file    //TODO - db.properties are not yet updated here
    def command =  ["${tools_ant_cmd}", "setup_db_properties"]
    commandStep(command, true, demodataDir)
    command =  ["${tools_ant_cmd}", "-q", "load_pmdata"]
    commandStep(command, true, demodataDir)
    command =  ["${tools_ant_cmd}", "-q", "load_hivedata"]
    commandStep(command, true, demodataDir)
    command =  ["${tools_ant_cmd}", "-q", "load_demodata"]
    commandStep(command, true, demodataDir)
    command =  ["${tools_ant_cmd}", "-q", "load_metadata"]
    commandStep(command, true, demodataDir)
    command =  ["${tools_ant_cmd}", "-q", "load_workdata"]
    commandStep(command, true, demodataDir)
}

target(i2b2Coreserver: "i2b2Coreserver - building the core i2b2 modules used by tranSMART")
{
    def i2b2Dir = build_dir | "i2b2_1.6_postgres"
//    coreserver - source files for building the core i2b2 modules used by tranSMART
    def coreserver_subdir = i2b2Dir | "coreserver/src"
//
//    SUMMARY of all the files that need modification
//    (relative to BASE_DIR)
//    ./edu.harvard.i2b2.common/build.properties
//    jboss.home=YOUR_JBOSS_HOME_DIR
//    ant clean dist deploy jboss_pre_deployment_setup
    replacePropertyInFile(coreserver_subdir | "edu.harvard.i2b2.common/build.properties",
                            "jboss.home", locations_jboss)
    def command =  ["${tools_ant_cmd}", 'clean', 'dist', 'deploy', 'jboss_pre_deployment_setup']
    commandStep(command, true, coreserver_subdir | "edu.harvard.i2b2.common")
//
//    ./edu.harvard.i2b2.pm/build.properties
//    jboss.home=YOUR_JBOSS_HOME_DIR
    //>>>>>> TODO - not done now:
//            ./edu.harvard.i2b2.pm/etc/jboss/pm-ds.xml
//     you may have to modify: connection-url, user-name, and password
    //<<<<<<<
//    ant -f master_build.xml clean build-all deploy
    replacePropertyInFile(coreserver_subdir | "edu.harvard.i2b2.pm/build.properties",
            "jboss.home", locations_jboss)
    command =  ["${tools_ant_cmd}", '-f', 'master_build.xml', 'clean', 'build-all', 'deploy']
    commandStep(command, true, coreserver_subdir + "/edu.harvard.i2b2.pm")
//
//    ./edu.harvard.i2b2.ontology/build.properties
//    jboss.home=YOUR_JBOSS_HOME_DIR
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.ontology/build.properties",
            "jboss.home", locations_jboss)
    //>>>>>> TODO - not done now:
//            ./edu.harvard.i2b2.ontology/etc/jboss/ont-ds.xml
//    you may have to modify: connection-url, user-name, and password
//    changes may be necessary for: i2b2hive, i2b2metadata, and i2b2metadata2
    //<<<<<<<
//        ./edu.harvard.i2b2.ontology/etc/spring/ontology_application_directory.properties
//    set edu.harvard.i2b2.ontology.applicationdir
//    to YOUR_JBOSS_HOME_DIR/server/default/conf/ontologyapp
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.ontology/etc/spring/ontology_application_directory.properties",
            "edu.harvard.i2b2.ontology.applicationdir", locations_jboss + "/server/default/conf/ontologyapp")
//    ant -f master_build.xml clean build-all deploy
    command =  ["${tools_ant_cmd}", '-f', 'master_build.xml', 'clean', 'build-all', 'deploy']
    commandStep(command, true, coreserver_subdir + "/edu.harvard.i2b2.ontology")
//
//    ./edu.harvard.i2b2.crc.loader/build.properties
//    jboss.home=YOUR_JBOSS_HOME_DIR
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.crc.loader/build.properties",
            "jboss.home", locations_jboss)
//            ./edu.harvard.i2b2.crc.loader/etc/spring/crc_loader_application_directory.properties
//    set edu.harvard.i2b2.crc.loader.applicationdir to be
//    YOUR_JBOSS_HOME_DIR/server/default/conf/crcapp
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.crc.loader/etc/spring/crc_loader_application_directory.properties",
            "edu.harvard.i2b2.crc.loader.applicationdir", locations_jboss + "/server/default/conf/crcapp")
//    ant -f build.xml clean dist
    command =  ["${tools_ant_cmd}", '-f', 'build.xml', 'clean', 'dist']
    commandStep(command, true, coreserver_subdir + "/edu.harvard.i2b2.crc.loader")
//
//    ./edu.harvard.i2b2.crcplugin.patientcount/build.properties
//    crcplugin.home=YOUR_JBOSS_HOME_DIR/server/default
//    jboss.home=YOUR_JBOSS_HOME_DIR
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.crcplugin.patientcount/build.properties",
            "crcplugin.home", locations_jboss + "/server/default")
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.crcplugin.patientcount/build.properties",
            "jboss.home", locations_jboss)
//            ./edu.harvard.i2b2.crcplugin.patientcount/etc/spring/patientcount_application_directory.properties
//    set edu.harvard.i2b2.crcplugin.pb.applicationdir
//    to YOUR_JBOSS_HOME_DIR/server/default/conf/crcapp
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.crcplugin.patientcount/etc/spring/patientcount_application_directory.properties",
            "edu.harvard.i2b2.crcplugin.pb.applicationdir", locations_jboss + "/server/default/conf/crcapp")
//    no build HERE???
//
//    ./edu.harvard.i2b2.crc/build.properties
//    jboss.home=YOUR_JBOSS_HOME_DIR
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.crc/build.properties",
            "jboss.home", locations_jboss)
//            ./edu.harvard.i2b2.crc/etc/spring/crc_application_directory.properties
//    set edu.harvard.i2b2.crc.applicationdir to be
//    YOUR_JBOSS_HOME_DIR/server/default/conf/crcloaderapp
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.crc/etc/spring/crc_application_directory.properties",
            "edu.harvard.i2b2.crc.applicationdir", locations_jboss + "/server/default/conf/crcloaderapp")
//    ant -f master_build.xml clean build-all deploy
    command =  ["${tools_ant_cmd}", '-f', 'master_build.xml', 'clean', 'build-all', 'deploy']
    commandStep(command, true, coreserver_subdir + "/edu.harvard.i2b2.crc")
//
//    ./edu.harvard.i2b2.workplace/build.properties
//    jboss.home=YOUR_JBOSS_HOME_DIR
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.workplace/build.properties",
            "jboss.home", locations_jboss)
//            ./edu.harvard.i2b2.workplace/etc/spring/workplace_application_directory.properties
//    set edu.harvard.i2b2.workplace.applicationdir
//    to YOUR_JBOSS_HOME_DIR/server/default/conf/workplaceapp
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.workplace/etc/spring/workplace_application_directory.properties",
            "edu.harvard.i2b2.workplace.applicationdir", locations_jboss + "/server/default/conf/workplaceapp")
//    ant -f master_build.xml clean build-all deploy
    command =  ["${tools_ant_cmd}", '-f', 'master_build.xml', 'clean', 'build-all', 'deploy']
    commandStep(command, true, coreserver_subdir + "/edu.harvard.i2b2.workplace")
//
//
//    ./edu.harvard.i2b2.fr/build.properties
//    jboss.home=YOUR_JBOSS_HOME_DIR
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.fr/build.properties",
            "jboss.home", locations_jboss)
//            ./edu.harvard.i2b2.fr/etc/spring/fr_application_directory.properties
//    set edu.harvard.i2b2.fr.applicationdir
//    to YOUR_JBOSS_HOME_DIR/server/default/conf/frapp
    replacePropertyInFile(coreserver_subdir + "/edu.harvard.i2b2.fr/etc/spring/fr_application_directory.properties",
            "edu.harvard.i2b2.fr.applicationdir", locations_jboss + "/server/default/conf/frapp")
//    ant -f master_build.xml clean build-all deploy
    command =  ["${tools_ant_cmd}", '-f', 'master_build.xml', 'clean', 'build-all', 'deploy']
    commandStep(command, true, coreserver_subdir + "/edu.harvard.i2b2.fr")
}

target(createTransmartDB: "createTransmartDB")
{
    def command = "CREATE DATABASE $transmart_db_name " +
            "WITH OWNER = $pg_effective_user TEMPLATE template0 " +
            "ENCODING='UTF-8' LC_COLLATE='en_US.UTF-8'"

    dbCommand([:], command)
}

target(ensureTablespaces: "create tablespace directories")
{
    def scriptUser = System.getProperty("user.name")
    def attemptChown = host_os_type == 'unix' && scriptUser == 'root' &&
            pg_process_user

    if (!attemptChown && pg_process_user && scriptUser != pg_process_user) {
        warn "We need to have tablespace directories that are owned by " +
                "the user %s. Since we are not running as root, this " +
                "will not be possible. Consequently, the script WILL " +
                "FAIL unless you have previously ensured that the " +
                "directories under %s exist and are owned by %s",
                pg_process_user, transmart_db_tablespace_location,
                pg_process_user
    }
    if (!attemptChown && !pg_process_user) {
        warn "We need to have tablespace directories that are owned by " +
                "the user postgres runs as. But since we were unable to " +
                "determine which user that is, we cannot do that. You will " +
                "still have to ensure that the directories under %s exist " +
                "and are owned by the postgresql user. Otherwise, the script " +
                "WILL FAIL at later stages",
                transmart_db_tablespace_location
        pause()
    }


    mkdir(dir: transmart_db_tablespace_location)
    ['deapp','biomart','transmart','indx','search_app'].each {
        def db_dir = transmart_db_tablespace_location | it;

        mkdir(dir: db_dir);
        if (attemptChown) {
            chown(owner: pg_process_user, type: 'dir', file: db_dir)
        } else if (pg_process_user) {
            try {
                Class.forName('java.nio.file.Files')
                String owner = java.nio.file.Files.getOwner(
                        java.nio.file.Paths.get(db_dir)).name
                if (owner != pg_process_user) {
                    fail "Owner of %s should be %s, but it's %s and we are " +
                            "unable to do anything about it. Aborting",
                            db_dir, pg_process_user, owner
                }
            } catch (ClassNotFoundException cnfe) {
                warn "Cannot detect owner for %s (only possible in Java 7)",
                        db_dir
                warn "ASSUMING THE OWNER IS CORRECT"
            }
        }
    }
}

target(verifySEARCHAPPdata: "verify SEARCHAPP data")
{
    dbScriptStep(build_dir |
            "transmartApp-DB/postgresql/searchapp/data/check_counts.sql",
            transmart_db_name, true, false, ".")

    FileReader reader = new FileReader(ant_last_step_output)
    def counts = readCounts(reader.readLines())

    //verify some of the counts:
    assertEquals(counts,"SEARCH_KEYWORD_TERM",105844)
    assertEquals(counts,"SEARCH_KEYWORD",42114)
    assertEquals(counts,"SEARCH_REQUEST_MAP",17)
    assertEquals(counts,"PLUGIN_MODULE",11)
}


target(verifyDEAPPdata: "verify DEAPP data")
{
    dbScriptStep(build_dir |
            "transmartApp-DB/postgresql/deapp/data/check_counts.sql",
            transmart_db_name, true, false, ".")

    FileReader reader = new FileReader(ant_last_step_output)
    def counts = readCounts(reader.readLines())

    //verify some of the counts:
    assertEquals(counts,"DE_SUBJECT_MICROARRAY_DATA",54400)
    assertEquals(counts,"DE_MRNA_ANNOTATION",5440)
    assertEquals(counts,"DE_SUBJECT_SAMPLE_MAPPING",10)
    assertEquals(counts,"DE_SAVED_COMPARISON",5)
}

target(verifyBIOMARTdata: "verify DEAPP data")
{
    dbScriptStep(build_dir |
            "transmartApp-DB/postgresql/biomart/data/check_counts.sql",
            transmart_db_name, true, false, ".")

    FileReader reader = new FileReader(ant_last_step_output)
    def counts = readCounts(reader.readLines())

    //verify some of the counts:
    assertEquals(counts,"BIO_ASSAY_FEATURE_GROUP",237002)
    assertEquals(counts,"BIO_ASSAY_ANALYSIS_DATA",184538)
    assertEquals(counts,"BIO_DATA_EXT_CODE",134965)
    assertEquals(counts,"BIO_DATA_UID",126764)
}


//======================= UTILITY METHODS ==============================================================

def readCounts(readLines)
{
    def counts = [:]
    readLines.each {
        def matcher = it =~ /^\s*(\w*)\s*\|\s*(\d+)\s*$/
        if (matcher) counts[matcher.group(1)] = matcher.group(2)
    }
    counts
}

def assertEquals(map,key,value)
{
    info "checking: ${key} | ${map[key]} = ${value} ..."
    assert map[key].toString().equals(value.toString())
}

Thread tailThread(File file) {
    def safeSize = {
        def lastSize
        try {
            lastSize = file.size()
        } catch (FileNotFoundException fnf) {
            lastSize = 0
        }
        lastSize
    }

    new Thread({
        def lastSize = safeSize()

        try {
            while (true) {
                Thread.sleep(500)

                def currentSize = safeSize()
                if (currentSize < lastSize) {
                    lastSize = 0
                }
                if (currentSize == lastSize) {
                    continue
                }

                def fis = null
                try {
                    try {
                       fis = new FileInputStream(file)
                    } catch (FileNotFoundException fn) {
                        continue
                    }

                    byte[] buffer = new byte[8192]
                    int left = currentSize - lastSize

                    fis.skip(lastSize)
                    while (left > 0) {
                        def read = fis.read(buffer, 0, Math.min(left, 8192))
                        if (read == -1)
                            break

                        System.out.print(new String(buffer, 0, read, "ISO-8859-1"))
                        left -= read
                    }

                    lastSize = currentSize
                } finally {
                    if (fis)
                        fis.close()
                }
            }
        }  catch (InterruptedException ie) {
            // exit thread
        }
    } as Runnable)
}

def commandStepN(Map args = [:], command)
{
    args = new HashMap(args)

    args.failOnError = args.failOnError == null ? true : args.failOnError
    args.dir         = args.dir ?: '.'
    args.inputString = args.inputString
    args.quiet       = args.quiet == null ? false : args.quiet
    args.timeout     = args.timeout == null ? 600000 : args.timeout
    args.output      = args.output == null ? ant_last_step_output : args.output;
    args.environment = args.environment ?: [:]

    if (!args.callback) {
        commandStep(command, args.failOnError, args.dir, args.inputString,
                args.quiet, args.timeout, args.output, args.environment)
    } else {
        args.callback(args, command)
    }
}

def pause() {
    System.err.println("Press ENTER to continue")
    System.in.read()
    System.in.skip(System.in.available())
}

def commandStep(command, failOnError, dir=".", inputString=null, quiet=false,
                timeout = 600000, output=ant_last_step_output, environment=[:])
{
    // Uncomment this for an interactive mode:
    //println "About to execute $command on dir ${dir ? dir : 'CWD' }..."
    //pause()

    //workaround for quotes in dir...this gives problems, so remove all
    dir = dir.replaceAll("\"", "")

    def outputThread = null
    if (!quiet) {
        outputThread = tailThread(output instanceof File
                                  ? output
                                  : new File(output))
        outputThread.start()
    }

    def ant = new AntBuilder()
    try {
        def executable = command.get(0)
        //remove executable from list:
        command.remove(0)

        info "Executing %s %s", executable, command.collect { "'$it'" }.join(" ")

        ant.exec(dir: dir,
                failonerror: failOnError,
                inputstring: inputString,
                output: output,
                timeout: timeout,
                resultProperty: "cmdExit",
                executable: executable)
                {
                    command.each {
                        arg(value: it)
                    }
                    environment.each { k, v ->
                        env(key: k, value: v)
                    }
                }

    } catch (Exception e) {
        fail "Exception was raised: %s", e.message
    } finally {
        outputThread?.interrupt()
    }

    ant.project.properties.cmdExit == "0" ? true : false
}

def gitStep(repositoryUrl, destDir, branch=null, failOnError=true)
{
    def targetDir = new File(destDir)

    if (!targetDir.exists()) {
        def command = [tools_git_cmd, 'clone', repositoryUrl, destDir]
        //checkout specified branch :
        if (branch)
        {
            if (git_has_single_branch)
                command.add('--single-branch')

            command.add("-b")
            command.add(branch)
        }
        commandStep(command, failOnError, ".", null, false, 1800000) //TODO show progress...perhaps by reading output in a separate thread...?
    }
    else {
        /* maybe we should check whether the repository is dirty/deviated from origin & abort */

        def command = [tools_git_cmd, 'fetch', '-q', 'origin']
        commandStep(command, failOnError, destDir, null, false, 1800000)

        command = [tools_git_cmd, 'rev-parse', '--abbrev-ref', '--symbolic-full-name',  '@{u}']
        def proc = command.execute([], targetDir)
        proc.waitFor()
        def ref = proc.in.text.trim()

        command = [tools_git_cmd, 'reset', '--hard', '-q', ref]
        commandStep(command, failOnError, destDir)
    }
}

def maybeSudoize(Map map = [:], command)
{
    def user = map.user ?: psql_sudo_user
    psql_sudo_user ? ['sudo', '-E', '-u', user, *command] : command
}

def executePsql(Map map = [:], List<String> extraParams, tool = null)
{
    def databaseName = map.database ?: pg_database
    map.environment  = map.environment ?: [:]
    tool             = tool ?: tools_psql_cmd

    params = ['-d', databaseName]
    if (pg_user) {
        params << '-U'
        params << pg_user
    }
    if (pg_host) {
        params << '-h'
        params << pg_host
    }
    if (pg_port) {
        params << '-p'
        params << pg_port
    }
    if (pg_password) {
        map.environment.PGPASSWORD = pg_password
    }

    def command = maybeSudoize([tool, *params, *extraParams])
    commandStepN(map, command)
}

def dbCommand(Map map = [:], sqlCommand)
{
    executePsql(map, ['-c', sqlCommand])
}

def dbScriptStep(scriptFileName, databaseName, failOnError=true, quiet=true, dir = ".", password=null)
{
    info "About to execute SQL script %s", scriptFileName

    def extraParams = ["-f", scriptFileName]

    if (quiet) {
        extraParams << "--quiet"
    }

    executePsql(extraParams, database: databaseName, failOnError: failOnError,
            dir: dir, timeout: 36000000)
}


def replaceInFile(String fileName, String value, String newValue)
{
    def fileAsString = file2String(fileName)
    fileAsString = fileAsString.replaceAll(value, newValue)
    string2File(fileAsString, fileName)
}


def fixTablespaceLocation(String scriptFileName)
{
    //read script file and replace
    // /opt/PostgreSQL/9.1/data/tablespaces/
    //with
    // transmart_db_tablespace_location
    def scriptTemp = file2String(scriptFileName)
    scriptTemp = scriptTemp.replaceAll("/opt/PostgreSQL/9.1/data/tablespaces", transmart_db_tablespace_location)
    string2File(scriptTemp, scriptFileName)
    return scriptFileName;
}

/**
 * quick method, handy for SMALL files
 *
 * @return
 * @throws java.io.IOException
 */
public static String file2String(String fileName) throws IOException
{
    InputStream fileInputStream = new FileInputStream(new File(fileName))
    String result = "";
    try
    {
        byte[] buf = new byte[2048];
        int i = 0;
        while((i=fileInputStream.read(buf))!=-1)
        {
            result += new String(buf, 0, i);
        }
    }
    finally
    {
        fileInputStream.close();
    }
    return result;
}

private static String string2File(String value, String fileName) throws IOException
{
    FileWriter outFile = new FileWriter(fileName);

    try
    {
        outFile.write(value)
    }
    finally
    {
        outFile.close();
    }

}

def readProperties(propertiesFileName)
{
    def propertiesFile = new FileReader(propertiesFileName)
    def properties = new Properties()
    properties.load(propertiesFile)
    propertiesFile.close()

    properties
}
/**
 * This method will replace the value of the given property with the given value in the
 * property file.
 *
 * @param propertiesFileName : .property file to change
 * @param propertyName       : the property to change (e.g. "jboss.home" )
 * @param newPropertyValue   : the new value for this property
 * @param putQuotes          : if it is a Groovy properties file, then we should (?) quote string (like file paths)
 */
def replacePropertyInFile(propertiesFileName, propertyName, newPropertyValue, putQuotes = false)
{
    //workaround for quotes in dir...this gives problems, so remove all
    propertiesFileName = propertiesFileName.replaceAll("\"", "")
    if (putQuotes)
        newPropertyValue = "\"" + newPropertyValue + "\""

    def propertiesFileContent = file2String(propertiesFileName)
    propertiesFileContent = propertiesFileContent.replaceAll(propertyName + ".*\\n", propertyName + " = " + newPropertyValue + "\n")
    string2File(propertiesFileContent, propertiesFileName)

    / * the implementation below is more elegant, but it messes up the properties file (both the order of the properties and the comments)
    def properties = readProperties(propertiesFileName)
    properties.setProperty(propertyName, newPropertyValue)
    def output = new FileOutputStream(propertiesFileName)   */
    //the # character added here gives problems in Groovy parser ! properties.store(output, "# nb: " + propertyName + " changed by transmastAppIntaller ")
    //output.close()
}

def which(String executable) {
    def separator = host_os_type == 'windows' ? ';' : ':'
    def paths = System.getenv().PATH.split(separator) /* does not handle quoted paths */

    paths.findResult {
        def fullPath = it | executable | exec_postfix
        new File(fullPath).canExecute() ? fullPath : null
    }
}


def echo(String severity, String format, Object... args) {
    ant.echo message: sprintf(format, args), level: severity
}
def fail(String format, Object... args) {
    ant.fail message: sprintf(format, args)
}

/**
 * Returns the system/user's temporary directory
 *
 * @return
 */
def getTempDir()
{
    System.getProperty("java.io.tmpdir")
}
/* vim: set ts=4 sw=4 tw=120 et filetype=groovy :*/
